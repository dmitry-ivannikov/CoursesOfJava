0
git config --global user.name "Ivannikov Dmitry"
git config --global user.email "ivannikov.dmitry.v@gmail.com"

git init

локальная конфигурация

в каталоге репозитория
git config  user.name "Test Testovich"
git config  user.email "test@test" // можно также зайти в папку .git открыть файл config и в ручную всё прописать

1 
git add .// git add file.txt
gitk - ui для git

git commit -m"comment for commit"

2
git status

преименование файла засценивается как удаление и добавление нового

нужно добавить (add) переименованный файл, тогда гит поймёт, что он переименован

git add . если мы в каком то каталоге проекта, то будут добавлены только файлы в этом каталоге

git add * добавить все непроиндексированные и пометить как кондидаты в коммит(сущее зло
: Добавятся не изменившиеся с прошлого коммита файлы. Git спокойно и молча "прожует" этот запрос, не влияющий на индекс.
Будут добавлены в индекс файлы в не-скрытых папках M,?.
Не будут добавлены файлы в скрытых папках. .M, .?
Не будут добавлены удаленные файлы D.
Если будут захвачены игнорируемые файлы !, то будет попытка их добавить. Git отменит всю операцию и покажет сообщение об ошибке.

)

https://ru.stackoverflow.com/questions/431839/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-git-add-add-a-add-u-%D0%B8-add

модификация файла-> требует коммита

4 git log (история коммотв (как понятно в проекте))
git log --pretty=oneline (1 коммит одна строка (сжатое отображение))
git log --pretty=oneline --max-count=3 (3 последних)
git log --pretty=oneline --max-count=all
git log --pretty=oneline --author="Test Testovich"
git log --pretty=format:"%h(короткая версия хеша) - %s(коммнтарий) : %ad(дата) [ %an(автор)]" --date=short
 
5 git checkout 
git checkout ff344b(сокращённый хеш коммита к которому хотим возратиться)
нашли проблемму меняем рабочую область (не меняем историю)
git checkout master вернулись к последнему пункту истории

6 Отмена индексированных файлов
git reset HEAD(HEAD - взять до add можно воткнуть хеш коммита) file.txt// по сути отменяет комманду add 
git checkout file.txt - вернёт файл в состояние последнего коммита

7 revent отмена коммита
git revert HEAD -создать новый коммит с содержанием предыдущего
git revert ff344b - создать новый коммит с содержанием определённого 
если конфликт
git revert --abort (отменить revert - здорово, правда!!!)

если при revert произошел конфликт (например откатились до момента добавления файла - гит говорит: не знаю что за файл и что с ним делать)
сделать add этого файла, а затем git revert --continue (завершить попытку revert, меняем состояние коммита, но не рабочей области )

9 git branch - покажет локальные ветки
git checkout -b newBranch - создание и переключение в новою ветку
отросток идёт из ветки из которой мы её создаём и копирует всё от родителя
git checkout master - переключились в мастер

10 продолжение к 9
git checkout dev
создали file2
git checkout master
git marge dev - в ветку мастер добавили изменениея из dev
в ветке мастер появится все коммиты ветки  dev
*****
частая ситуёвина: мастер изменился(в мастере произошел коммит) а в dev нет этих изменений
в dev меняем тот же файл
пытемся переключиться на мастер - ругается, что есть неиндексируемый файл
добавляем, коммитим
переключиличсь в мастер
из мастреа 
git marge dev - говорит конфликт
git status - двойная модификация файла
при просмотре файла через знак ====== сверху отображается родительская ветка, снизу дочерняя - редактируем как нам надо
индексируем и комитим(но без комментария - т к git по умолчанию предложит добавить комментарий и конфликте) wq(записать и выйти)

11 git rebese - подтягиваем изменения в dev из master или наоборот, очень похоже на marge, но
rebase не сохраняет историю коммитов:
dev 1, 3
мастер 2, 4
даст нам 2, 4, 1, 3
в то время как marge даст нам 1, 2, 3, 4 


12 git clone <url of rep>
git remote add origin <url удалённого репа> - в первый раз но пошлёт нас нахоен т к на github мы не добавлены в collaborations -  подтвердить преглашение - после этого всё можно)))

13 git push
 git push origin master
git push origin dev - создаст удалённо ветку dev

14 тянем merge и rebase

git pull origin master - тянем к себе из мастера
git pull --rebase origin master - возьмёт последний коммит, накитит все изменения из удалённого репозитория, а только после этого попытается накатить локальные изменения

15 origin & stash

имеем непроиндексированные изменения, хотим подтянуть с удалённого репозитория
git stash(отложили со стола всё наше)
git pull --rebase origin master подтянули что хотели
git stash pop - положили на изменения наши наработки - остались наши непроиндексированные изменения

может быть много stasheй хранят номер стеша ветку и короткий хеш коммита
посмотреть git stash list
git stash show покажет последние изменения со стешами
git stash apply накатить к себе последний стеш
git stash drop - удалить последний стеш
git stash pop - добавит последний и удалит стеш
git stash clear - удалить всё нахрен все стеши

git remote покажет origin - имя удалённого репозитория
git remote -v - покажет ссылки удалённых репозиториев

***git fetch***

